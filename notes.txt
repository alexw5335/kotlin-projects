Simple instruction encoding
- Use flags for each instruction's operand encodings
	- MEM
	- R8
	- R
	- IMM
	- IMM8
	- AL
	- A
	- reserved
- An operand can give a single flag bit that is then checked against these flags
	- e.g. ADD RM R, operand 1 has flag bits (R | MEM | A), operand 2 has flag bits (R | A)
- Encodings are ordered by their specificity (presumably already done so in the Intel manuals)
	- e.g. ADD AL, IMM8 comes before ADD RM8 IMM8
- Any instruction that doesn't fit this scheme would instead use a custom predicate
	- These instructions will be used very rarely



struct InstructionEncoding2 {
	u8 operands
	InstructionEncoding* encoding
}



struct InstructionEncoding {
	u8 mandatoryPrefix
	u8 sizePrefix
	u8 opType
	u8 opcode
	u8 extension // Also contains information about ModRM/Mod extension
	u8 operand1
	u8 operand2
	u8 operand3
	u8 operand4
	u8[7] reserved
}

Instructions that use opcode registers:
- push r16/64 (64-bit default)
- pop r16/64  (64-bit default)
- xchg
- mov r8, imm8
- mov r/16/32/64, imm/16/32/64
- bswap r/16/32/64

Instructions with 3 or 4 operands
- IMUL
- SHLD
- SHRD
- Many SIMD instructions

- An instruction must specify the operand types that can be used
- An instruction must also specify how those operands are encoded
	- For most of the same combinations of operands, these encodings are the same
		- e.g. almost all R, RM instructions are encoded the same way
	- Sometimes, different encodings are used, such as the opcode register
- For simplicity, all instructions are assumed to follow the main encoding principles
- Instructions that do not follow these principles are encoded separately by hand
- E.g. opcode register variations of PUSH and POP are encoded separately.
	- However, the variations of PUSH and POP that do follow the standard encoded are encoded normally
- Flag bits are still used to choose the specific instruction encoding for a mnemonic
	- An instruction must specify whether it uses custom encoding


Operand types:
- r/m8
- r/m16/32/64
- r8
- r16/32/64
- al
- ax/eax/rax
- imm8
- imm16/32
- opcode r64/r16 (push/pop)
- r32/r64 (movsxd)
- m8, m16, m32 (explicit operand, INS/OUTS/MOVS, etc.)
- dx (explicit operand, OUTS)
- rel8
- Sreg (mov)
- dx/edx/rdx (cwd/cdq/cqo)
- support explicit operands? Probably not. Nasm doesn't seem to.
- moffs8
- moffs16/32/64 (mov)
- imm16

struct Instruction {

}

// 8 bytes in size
union AstNode {
	RegisterNode  register
	ImmediateNode immediate
	AddressNode   address
}

struct RegisterNode {
	u8 registerType
	u8 register
}

struct ImmediateNode {
	s64 immediate
}

struct AddressNode2 {
	u8 modrm   // will be combined with other operands
	u8 sib     // if needed
	u32 offset // if needed
}

struct AddressNode {
	u8 width  // 32 or 64-bit general-purpose (64-bit by default)
	u8 base   // A 32 or 64-bit gp register
	u8 index  // A 32 or 64-bit gp register
	u32 offset
}

- R RM expands to:
	- REG16 MEM
	- REG16 REG16
	- REG32 MEM
	- REG32 REG32
	- REG64 MEM
	- REG64 REG64
- Or perhaps:
	- REG MEM
	- REG REG
- For the second version, the width can be extracted from REG
- Or, it could simply be left as R RM and flag bits can be used instead
- 16-bit flag bits

	/*

	16-bit operand type
		8-bit class
		7-bit flags
		1-bit mem for all classes

	classes:
		REG
			REG16
			REG32
			REG64
			AX
			EAX
			RAX
			DX
			MEM
		REG8
			AL
			CL
			MEM
		IMM
			IMM8
			IMM16
			IMM32
			IMM64
		XMM
			XMM0
			MEM
		YMM
			YMM0
			MEM
		ZMM
			ZMM0
			M32BCST
			M64BCST
			MEM

	val classValue =
		((op1.value and 0xFF) shl 0) or
		((op2.value and 0xFF) shl 8) or
		((op3.value and 0xFF) shl 16) or
		((op4.value and 0xFF) shl 24)

	val typeValue =
		((op4.value and 0xFF00) shl 16) or
		((op3.value and 0xFF00) shl 8) or
		((op2.value and 0xFF00) shl 0) or
		((op1.value and 0xFF00) shr 8)


	for each encoding, check:
		classValue == encoding.classValue
		encoding.typeValue and typeValue == encoding.typeValue


	- This does not work
	- MEM will not be shared between classes with AND
	- Nothing but a true flag bits will work.
	- 16-bit Flag Bits:
		MEM
		R
		R8
		A
		AL
		CL
		DX
		IMM8
		IMM
		XMM
		YMM
		ZMM
	- Flag bits may need to be extended to 32 bits?
	*/

Register representation
- First byte: register type
- Second byte: register value
- types:
	0 R8
	1 R16
	2 R32
	3 R64
	4 ST
	5 MMX
	6 XMM
	7 YMM
	8 ZMM

mov byte [rax + rcx * 2 + label + 1000], 10
- ADD(RAX, ADD(MUL(RCX, 2), ADD(label, 1000)))
- ADD
	RAX
	ADD
		MUL
			RCX
			2
		ADD
			label
			1000

mov byte [label + 1000 + rax * 2 + rcx]
ADD
	label
	ADD
		1000
		ADD
			MUL
				rax
				2
			RCX

- Need to determine:
	- base register
	- index register
	- scale
	- displacement
- Must simplify to the form:
	- base + index * scale + displacement

- AST simplification
- 1 + 2 + PI
	- ADD(ADD(1, 2), PI)
- 1 + PI + 2
	- ADD(ADD(1, PI), 2)

Newline note:
Both valid newline usages:

symbol
	.node
	.calculate()

symbol.
	node.
	calculate()

Checking for expression ends may be complicated.

Symbols
- Symbols are identified during parsing
- Symbols are names that are associated with a type and a node that represents its value
- Symbols are resolved by the assembler and then stored as resolved symbols
- The parser determines CONST symbols as it parses them.

Assembler
- The assembler first produces a stream of instructions
- The instructions are not yet encoded.
- An instruction in this stage consists only of its mnemonic, encoding, and length.

Encoding chooser
- Encodings are represented by a tree
- Operand types
	- register (must refer to a register)
	- immediate (can be a literal or can refer to an expression)
	- memory (same as immediate but surrounded by square brackets)
- One tree for each operand count
- Empty tree for no operands
- Can be collapsed into an array for simple encoding choosing
	- Use a tree later as optimisation
- Immediate value width is complicated
	- Multiple passes
- Operand tree
	- Each node has a predicate and a list of children
	- A leaf node consists of a predicate and an encoding
	- First layer: operand1 type (REG/MEM)
	- Second layer: operand2 specific type (REG8/MEM8)
	- This will not work. If MEM is first, cannot identify the correct encoding, which may be based on the second REG
	operand.
	- Difference between explicit and implicit memory widths.

ADD:

04    ADD  AL  IMM8
05    ADD  A   IMM
80/0  ADD  RM8 IMM8
81/0  ADD  RM  IMM
83/0  ADD  RM  IMM8
00    ADD  RM8 R8
01    ADD  RM  R
02    ADD  R8  RM8
03    ADD  R   RM

	 |||
	 |||
	\|||/
	 \|/

R8 IMM8  /  R8 IMM*
AL IMM8  /  AL IMM*
R8 R8
R8 M8  /  R8 M

R16 IMM8
AX  IMM16
R16 IMM16
R16 R16
R16 M16  /  R16 M

R32 IMM8
EAX IMM32
R32 IMM32
R32 R32
R32 M32  /  R32 M

R64 IMM8
RAX IMM32
R64 IMM32
R64 R64
R64 M64  /  R64 M

M8 IMM8
M8 R8  /  M R8

M16 IMM8
M16 IMM16
M16 R16  /  M R16

M32 IMM8
M32 IMM32
M32 R32  /  M R32

M64 IMM8
M64 IMM32
M64 R64  /  M R64



M_R = { op1 is MemoryNode && (op1.width == null || op1.width == op2.width) && op2 is RegisterNode }



R
	R8
	R16
	R32
	R64
M
	M*
	M8
	M16
	M32
	M64



Assembler stages
- lexer: converts text into tokens
- parser: converts tokens into nodes and creates a symbol table
- assembler
	- resolves constant nodes
	- converts instruction nodes into instruction prototypes

- Multiple passes are necessary
- The parser resolves const symbols after the first pass
- Labels may cause instruction length problems
	- Any instruction that references labels will use the longest instruction
	- Or, the instruction width can be specified, e.g.
		- add al, .end - .start (doesn't need specification)
		- add [rax], .end - .start (will cause an error, requires explicit width)
		- jmp .end - .start (will use rel32)
		- jmp byte .end - .start (will use rel8 but will throw an error if not in the correct range)

Newlines
- Use newlines as symbols if expressions don't go over newlines
- Use a newline list if expressions can go over newlines
- Consecutive newlines should not be tokenised.

Operand types
- 3 levels of types
- Level 1: REG, IMM, MEM
- Level 2: R8, R16, R32, R64, IMMn, IMM8, IMM16, IMM32, IMM64, MEMn, MEM8, MEM16, MEM32, MEM64
- Level 3: AL, CL, AX, DX, EAX, RAX, 0, 1, OTHER (level 3 not required)
- REG
	- R8
		- AL
		- CL
	- R16
		- AX
		- DX
	- R32
		- EAX
	- R64
		- RAX
- MEM
	- MEMn
	- MEM8
	- MEM16
	- MEM32
	- MEM64
- IMM
	- IMMn
	- IMM8
		- 0
		- 1
	- IMM16
	- IMM32
	- IMM64

- RegisterNode
	- u8 nodeType
	- u8 registerType
	- u8 registerValue
- MemoryNode
	- u8 nodeType
	- u8 width (implicit, undetermined, byte, word, dword, qword, ...)
	- ...
- ImmediateNode
	- u8 nodeType
	- u8 width (implicit, undetermined, byte, word, dword, qword)
	- s8, s16, s32, or index into s64 array

04    ADD  AL  IMM8    (IMM*)
05    ADD  A   IMM     (IMM*)
80/0  ADD  RM8 IMM8
81/0  ADD  RM  IMM     (IMM*)
83/0  ADD  RM  IMM8
00    ADD  RM8 R8
01    ADD  RM  R
02    ADD  R8  RM8
03    ADD  R   RM

- Memory operands and immediate operands that reference labels use the largest possible encoding (pessimistic)
	- Memory operands default to 32-bit displacements (vs 8-bit) when a label is used
	- Immediate operands use the largest (usually 8-bit vs 16/32/64-bit or rel8 vs rel32) size encoding.
		- A reference can be kept to the smaller encoding to allow for later optimisation.

- An instruction node will produce the most specific encoding (e.g. AX, M16)
	- This is then ANDed with the flag bits of the instruction
	- The encoding index is found by counting the number of bits set before the matching bit.
	- AND will produce 0 if the encoding is invalid.
- Memory operands will match regardless of explicit width
	- Encodings will check for the correct width
	- Implicit width will be determined according to other operands
		- i.e. memory operand width will not be used to determine the encoding
	- Encodings that require explicit widths will check for them.
		- e.g. add [rax], 100 -> M_IMM, which should require explicit memory width
	- Immediates of indeterminate width will use the largest possible encoding.
		- e.g. R8_IMMN is an encoding that will have been auto-generated during encoding generation.
- Instruction length variation
	- Immediate length (rel8 vs rel32, imm8 vs imm16/32)
	- Memory length
		- May require SIB byte, may require disp8 or disp32

R
	R8
		_IMM8 -> R8_IMM8 or AL_IMM8
		_R8   -> R8_R8
		_M8   -> R8_M8
	R
		_IMM8 -> R_IMM8
		_IMM  -> R_IMM or A_IMM

- Some instruction encodings can have more specific versions
- e.g. imm8 can be a specialised version of imm32, e.g. R32_IMM32 -> R32_IMM8
- e.g. rax can be a specialised version of r64, e.g. R64_IMM32 -> RAX_IMM32
- Specificities are checked after checking the more general version.

1. Choose the general encoding, e.g. R64_IMM (but not RAX_IMM)
2. Search the mnemonic instruction group's flag bits for the presence of the general encoding
3. If the encoding bit's flag is not set, then the operands are invalid for that mnemonic
4. If the operands are valid, then the encoding's index in the instruction group's general encoding array is found
by counting the number of set bits before the operand encoding's bit.
5. The general encoding is checked for any specifier encodings, e.g. Shorter immediates, AL, AX, EAX, RAX, CL, DX, 1, 0
- The instructions must be laid out in the order of their operand encoding ordinals
- Any instructions with more specific operands must be placed at the end of the instruction list
- OperandsEncodings/InstructionEncodings can have multiple specifiers
	- e.g. R64_IMM32 -> R64_IMM8, R64_IMM32 -> RAX_IMM32
	- here, R64_IMM8 takes precedence over RAX_IMM32

Memory operands
- Traverse the AST node to determine the base, index, scale, and displacement
- BASE + INDEX * SCALE + DISPLACEMENT

Assembly
- The encoding is first chosen according to the operand nodes and the mnemonic
- Assembly is coordinated mostly by the encoding
- REX.W: 64-bit operand size
- REX.R: extends ModRM:reg for GPR, SSE, CR, or DR.
- REX.X: extends SIB:index
- REX.B: extends ModRM:rm, SIB:base, or opcode:reg
- Encodings are grouped by schemes
	- e.g. R8_R8, R16_R16, R32_R32, and R64_R64
	- These are encoded by ModRM:rm and ModRM:reg
- Group encodings?
	- RM_R: R16_R16, M16_M16, R32_R32, M32_R32, R64_R64, M64_R64
	- R_RM: R16_M16, R32_M32, R64_M64
	- reduce repetition
- steps:
	1. Determine width
	2. Determine operand types
	3. Identify memory operands

- import dll:KERNEL32:WriteFile

Simple PE File generation
- Takes a list of DLL imports and a byte array of code
- Two sections, .text and .idata