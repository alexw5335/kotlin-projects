Simple instruction encoding
- Use flags for each instruction's operand encodings
	- MEM
	- R8
	- R
	- IMM
	- IMM8
	- AL
	- A
	- reserved
- An operand can give a single flag bit that is then checked against these flags
	- e.g. ADD RM R, operand 1 has flag bits (R | MEM | A), operand 2 has flag bits (R | A)
- Encodings are ordered by their specificity (presumably already done so in the Intel manuals)
	- e.g. ADD AL, IMM8 comes before ADD RM8 IMM8
- Any instruction that doesn't fit this scheme would instead use a custom predicate
	- These instructions will be used very rarely



struct InstructionEncoding2 {
	u8 operands
	InstructionEncoding* encoding
}



struct InstructionEncoding {
	u8 mandatoryPrefix
	u8 sizePrefix
	u8 opType
	u8 opcode
	u8 extension // Also contains information about ModRM/Mod extension
	u8 operand1
	u8 operand2
	u8 operand3
	u8 operand4
	u8[7] reserved
}

Instructions that use opcode registers:
- push r16/64 (64-bit default)
- pop r16/64  (64-bit default)
- xchg
- mov r8, imm8
- mov r/16/32/64, imm/16/32/64
- bswap r/16/32/64

Instructions with 3 or 4 operands
- IMUL
- SHLD
- SHRD
- Many SIMD instructions

- An instruction must specify the operand types that can be used
- An instruction must also specify how those operands are encoded
	- For most of the same combinations of operands, these encodings are the same
		- e.g. almost all R, RM instructions are encoded the same way
	- Sometimes, different encodings are used, such as the opcode register
- For simplicity, all instructions are assumed to follow the main encoding principles
- Instructions that do not follow these principles are encoded separately by hand
- E.g. opcode register variations of PUSH and POP are encoded separately.
	- However, the variations of PUSH and POP that do follow the standard encoded are encoded normally
- Flag bits are still used to choose the specific instruction encoding for a mnemonic
	- An instruction must specify whether it uses custom encoding


Operand types:
- r/m8
- r/m16/32/64
- r8
- r16/32/64
- al
- ax/eax/rax
- imm8
- imm16/32
- opcode r64/r16 (push/pop)
- r32/r64 (movsxd)
- m8, m16, m32 (explicit operand, INS/OUTS/MOVS, etc.)
- dx (explicit operand, OUTS)
- rel8
- Sreg (mov)
- dx/edx/rdx (cwd/cdq/cqo)
- support explicit operands? Probably not. Nasm doesn't seem to.
- moffs8
- moffs16/32/64 (mov)
- imm16

struct Instruction {

}

// 8 bytes in size
union AstNode {
	RegisterNode  register
	ImmediateNode immediate
	AddressNode   address
}

struct RegisterNode {
	u8 registerType
	u8 register
}

struct ImmediateNode {
	s64 immediate
}

struct AddressNode2 {
	u8 modrm   // will be combined with other operands
	u8 sib     // if needed
	u32 offset // if needed
}

struct AddressNode {
	u8 width  // 32 or 64-bit general-purpose (64-bit by default)
	u8 base   // A 32 or 64-bit gp register
	u8 index  // A 32 or 64-bit gp register
	u32 offset
}

- R RM expands to:
	- REG16 MEM
	- REG16 REG16
	- REG32 MEM
	- REG32 REG32
	- REG64 MEM
	- REG64 REG64
- Or perhaps:
	- REG MEM
	- REG REG
- For the second version, the width can be extracted from REG
- Or, it could simply be left as R RM and flag bits can be used instead
- 16-bit flag bits

	/*

	16-bit operand type
		8-bit class
		7-bit flags
		1-bit mem for all classes

	classes:
		REG
			REG16
			REG32
			REG64
			AX
			EAX
			RAX
			DX
			MEM
		REG8
			AL
			CL
			MEM
		IMM
			IMM8
			IMM16
			IMM32
			IMM64
		XMM
			XMM0
			MEM
		YMM
			YMM0
			MEM
		ZMM
			ZMM0
			M32BCST
			M64BCST
			MEM

	val classValue =
		((op1.value and 0xFF) shl 0) or
		((op2.value and 0xFF) shl 8) or
		((op3.value and 0xFF) shl 16) or
		((op4.value and 0xFF) shl 24)

	val typeValue =
		((op4.value and 0xFF00) shl 16) or
		((op3.value and 0xFF00) shl 8) or
		((op2.value and 0xFF00) shl 0) or
		((op1.value and 0xFF00) shr 8)


	for each encoding, check:
		classValue == encoding.classValue
		encoding.typeValue and typeValue == encoding.typeValue


	- This does not work
	- MEM will not be shared between classes with AND
	- Nothing but a true flag bits will work.
	- 16-bit Flag Bits:
		MEM
		R
		R8
		A
		AL
		CL
		DX
		IMM8
		IMM
		XMM
		YMM
		ZMM
	- Flag bits may need to be extended to 32 bits?
	*/

Register representation
- First byte: register type
- Second byte: register value
- types:
	0 R8
	1 R16
	2 R32
	3 R64
	4 ST
	5 MMX
	6 XMM
	7 YMM
	8 ZMM