Simple instruction encoding
- Use flags for each instruction's operand encodings
	- MEM
	- R8
	- R
	- IMM
	- IMM8
	- AL
	- A
	- reserved
- An operand can give a single flag bit that is then checked against these flags
	- e.g. ADD RM R, operand 1 has flag bits (R | MEM | A), operand 2 has flag bits (R | A)
- Encodings are ordered by their specificity (presumably already done so in the Intel manuals)
	- e.g. ADD AL, IMM8 comes before ADD RM8 IMM8
- Any instruction that doesn't fit this scheme would instead use a custom predicate
	- These instructions will be used very rarely



struct InstructionEncoding2 {
	u8 operands
	InstructionEncoding* encoding
}



struct InstructionEncoding {
	u8 mandatoryPrefix
	u8 sizePrefix
	u8 opType
	u8 opcode
	u8 extension // Also contains information about ModRM/Mod extension
	u8 operand1
	u8 operand2
	u8 operand3
	u8 operand4
	u8[7] reserved
}

Instructions that use opcode registers:
- push r16/64 (64-bit default)
- pop r16/64  (64-bit default)
- xchg
- mov r8, imm8
- mov r/16/32/64, imm/16/32/64
- bswap r/16/32/64

Instructions with 3 or 4 operands
- IMUL
- SHLD
- SHRD
- Many SIMD instructions

- An instruction must specify the operand types that can be used
- An instruction must also specify how those operands are encoded
	- For most of the same combinations of operands, these encodings are the same
		- e.g. almost all R, RM instructions are encoded the same way
	- Sometimes, different encodings are used, such as the opcode register
- For simplicity, all instructions are assumed to follow the main encoding principles
- Instructions that do not follow these principles are encoded separately by hand
- E.g. opcode register variations of PUSH and POP are encoded separately.
	- However, the variations of PUSH and POP that do follow the standard encoded are encoded normally
- Flag bits are still used to choose the specific instruction encoding for a mnemonic
	- An instruction must specify whether it uses custom encoding


Operand types:
- r/m8
- r/m16/32/64
- r8
- r16/32/64
- al
- ax/eax/rax
- imm8
- imm16/32
- opcode r64/r16 (push/pop)
- r32/r64 (movsxd)
- m8, m16, m32 (explicit operand, INS/OUTS/MOVS, etc.)
- dx (explicit operand, OUTS)
- rel8
- Sreg (mov)
- dx/edx/rdx (cwd/cdq/cqo)
- support explicit operands? Probably not. Nasm doesn't seem to.
- moffs8
- moffs16/32/64 (mov)
- imm16

struct Instruction {

}

// 8 bytes in size
union AstNode {
	RegisterNode  register
	ImmediateNode immediate
	AddressNode   address
}

struct RegisterNode {
	u8 registerType
	u8 register
}

struct ImmediateNode {
	s64 immediate
}

struct AddressNode2 {
	u8 modrm   // will be combined with other operands
	u8 sib     // if needed
	u32 offset // if needed
}

struct AddressNode {
	u8 width  // 32 or 64-bit general-purpose (64-bit by default)
	u8 base   // A 32 or 64-bit gp register
	u8 index  // A 32 or 64-bit gp register
	u32 offset
}

- R RM expands to:
	- REG16 MEM
	- REG16 REG16
	- REG32 MEM
	- REG32 REG32
	- REG64 MEM
	- REG64 REG64
- Or perhaps:
	- REG MEM
	- REG REG
- For the second version, the width can be extracted from REG
- Or, it could simply be left as R RM and flag bits can be used instead
- 16-bit flag bits

	/*

	16-bit operand type
		8-bit class
		7-bit flags
		1-bit mem for all classes

	classes:
		REG
			REG16
			REG32
			REG64
			AX
			EAX
			RAX
			DX
			MEM
		REG8
			AL
			CL
			MEM
		IMM
			IMM8
			IMM16
			IMM32
			IMM64
		XMM
			XMM0
			MEM
		YMM
			YMM0
			MEM
		ZMM
			ZMM0
			M32BCST
			M64BCST
			MEM

	val classValue =
		((op1.value and 0xFF) shl 0) or
		((op2.value and 0xFF) shl 8) or
		((op3.value and 0xFF) shl 16) or
		((op4.value and 0xFF) shl 24)

	val typeValue =
		((op4.value and 0xFF00) shl 16) or
		((op3.value and 0xFF00) shl 8) or
		((op2.value and 0xFF00) shl 0) or
		((op1.value and 0xFF00) shr 8)


	for each encoding, check:
		classValue == encoding.classValue
		encoding.typeValue and typeValue == encoding.typeValue


	- This does not work
	- MEM will not be shared between classes with AND
	- Nothing but a true flag bits will work.
	- 16-bit Flag Bits:
		MEM
		R
		R8
		A
		AL
		CL
		DX
		IMM8
		IMM
		XMM
		YMM
		ZMM
	- Flag bits may need to be extended to 32 bits?
	*/

Register representation
- First byte: register type
- Second byte: register value
- types:
	0 R8
	1 R16
	2 R32
	3 R64
	4 ST
	5 MMX
	6 XMM
	7 YMM
	8 ZMM

mov byte [rax + rcx * 2 + label + 1000], 10
- ADD(RAX, ADD(MUL(RCX, 2), ADD(label, 1000)))
- ADD
	RAX
	ADD
		MUL
			RCX
			2
		ADD
			label
			1000

mov byte [label + 1000 + rax * 2 + rcx]
ADD
	label
	ADD
		1000
		ADD
			MUL
				rax
				2
			RCX

- Need to determine:
	- base register
	- index register
	- scale
	- displacement
- Must simplify to the form:
	- base + index * scale + displacement

- AST simplification
- 1 + 2 + PI
	- ADD(ADD(1, 2), PI)
- 1 + PI + 2
	- ADD(ADD(1, PI), 2)

Newline note:
Both valid newline usages:

symbol
	.node
	.calculate()

symbol.
	node.
	calculate()

Checking for expression ends may be complicated.

Symbols
- Symbols are identified during parsing
- Symbols are names that are associated with a type and a node that represents its value
- Symbols are resolved by the assembler and then stored as resolved symbols
- The parser determines CONST symbols as it parses them.

Assembler
- The assembler first produces a stream of instructions
- The instructions are not yet encoded.
- An instruction in this stage consists only of its mnemonic, encoding, and length.

Encoding chooser
- Encodings are represented by a tree
- Operand types
	- register (must refer to a register)
	- immediate (can be a literal or can refer to an expression)
	- memory (same as immediate but surrounded by square brackets)
- One tree for each operand count
- Empty tree for no operands
- Can be collapsed into an array for simple encoding choosing
	- Use a tree later as optimisation
- Immediate value width is complicated
	- Multiple passes
- Operand tree
	- Each node has a predicate and a list of children
	- A leaf node consists of a predicate and an encoding
	- First layer: operand1 type (REG/MEM)
	- Second layer: operand2 specific type (REG8/MEM8)
	- This will not work. If MEM is first, cannot identify the correct encoding, which may be based on the second REG
	operand.
	- Difference between explicit and implicit memory widths.

ADD:

04    ADD  AL  IMM8
05    ADD  A   IMM
80/0  ADD  RM8 IMM8
81/0  ADD  RM  IMM
83/0  ADD  RM  IMM8
00    ADD  RM8 R8
01    ADD  RM  R
02    ADD  R8  RM8
03    ADD  R   RM

	 |||
	 |||
	\|||/
	 \|/

R8 IMM8  /  R8 IMM*
AL IMM8  /  AL IMM*
R8 R8
R8 M8  /  R8 M

R16 IMM8
AX  IMM16
R16 IMM16
R16 R16
R16 M16  /  R16 M

R32 IMM8
EAX IMM32
R32 IMM32
R32 R32
R32 M32  /  R32 M

R64 IMM8
RAX IMM32
R64 IMM32
R64 R64
R64 M64  /  R64 M

M8 IMM8
M8 R8  /  M R8

M16 IMM8
M16 IMM16
M16 R16  /  M R16

M32 IMM8
M32 IMM32
M32 R32  /  M R32

M64 IMM8
M64 IMM32
M64 R64  /  M R64



Assembler stages
- lexer: converts text into tokens
- parser: converts tokens into nodes and creates a symbol table
- assembler
	- resolves constant nodes
	- converts instruction nodes into instruction prototypes

- Multiple passes are necessary
- The parser resolves const symbols after the first pass
- Labels may cause instruction length problems
	- Any instruction that references labels will use the longest instruction
	- Or, the instruction width can be specified, e.g.
		- add al, .end - .start (doesn't need specification)
		- add [rax], .end - .start (will cause an error, requires explicit width)
		- jmp .end - .start (will use rel32)
		- jmp byte .end - .start (will use rel8 but will throw an error if not in the correct range)